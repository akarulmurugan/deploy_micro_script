#include <WiFi.h>
#include <HTTPClient.h>
#include <ArduinoJson.h>
#include "esp_wifi.h"
#include "esp_wifi_types.h"

// ========== CONFIGURATION ==========
const char* WIFI_SSID = "Airtel_sath_0300";        // Your WiFi for ESP32 to connect
const char* WIFI_PASS = "Air@78546";               // Your WiFi password
const char* serverUrl = "http://192.168.1.3:8000/api/packet";
const char* YOUR_ROUTER_SSID = "Airtel_sath_0300"; // Your router SSID to protect

// ========== GLOBAL VARIABLES ==========
String esp32Mac = "";
String sensor_id = "esp32_wids_real";
unsigned long packetCount = 0;
unsigned long sentCount = 0;
unsigned long lastPacketTime = 0;
bool wifiConnected = false;
unsigned long lastReconnectAttempt = 0;
unsigned long lastHeartbeat = 0;

// Packet buffer to store detections when WiFi is down
#define PACKET_BUFFER_SIZE 50
struct BufferedPacket {
  char mac[18];
  int rssi;
  uint8_t channel;
  char attack_type[20];
  char ssid[33];
  unsigned long timestamp;
};
BufferedPacket packetBuffer[PACKET_BUFFER_SIZE];
int bufferHead = 0;
int bufferTail = 0;
int bufferCount = 0;

// ========== CUSTOM STRUCTURES ==========
typedef struct {
  unsigned frame_ctrl: 16;
  unsigned duration_id: 16;
  uint8_t addr1[6];
  uint8_t addr2[6];
  uint8_t addr3[6];
  unsigned sequence_ctrl: 16;
  uint8_t addr4[6];
} wifi_ieee80211_mac_hdr_t;

typedef struct {
  wifi_ieee80211_mac_hdr_t hdr;
  uint8_t payload[0];
} wifi_ieee80211_packet_t;

// ========== PROMISCUOUS MODE CALLBACK ==========
void wifi_sniffer_packet_handler(void* buf, wifi_promiscuous_pkt_type_t type) {
  if (type != WIFI_PKT_MGMT) return;
  
  const wifi_promiscuous_pkt_t* pkt = (wifi_promiscuous_pkt_t*)buf;
  const wifi_ieee80211_mac_hdr_t* hdr = (wifi_ieee80211_mac_hdr_t*)pkt->payload;
  
  // Get source MAC
  char source_mac[18];
  sprintf(source_mac, "%02X:%02X:%02X:%02X:%02X:%02X",
          hdr->addr2[0], hdr->addr2[1], hdr->addr2[2],
          hdr->addr2[3], hdr->addr2[4], hdr->addr2[5]);
  
  int rssi = pkt->rx_ctrl.rssi;
  
  // Get current channel
  uint8_t channel = 0;
  wifi_second_chan_t second;
  esp_wifi_get_channel(&channel, &second);
  
  // Get frame type
  uint16_t fc = hdr->frame_ctrl;
  uint8_t subtype = (fc >> 4) & 0x0F;
  uint8_t ptype = (fc >> 2) & 0x03;
  
  String attack_type = "";
  String ssid = "";
  
  // Detect Probe Requests
  if (ptype == 0 && subtype == 4) {
    uint8_t* frame_body = (uint8_t*)hdr + sizeof(wifi_ieee80211_mac_hdr_t);
    int offset = 0;
    offset += 12;
    
    while (offset < pkt->rx_ctrl.sig_len - sizeof(wifi_ieee80211_mac_hdr_t)) {
      uint8_t tag_number = frame_body[offset];
      uint8_t tag_length = frame_body[offset + 1];
      
      if (tag_number == 0 && tag_length > 0 && tag_length <= 32) {
        char ssid_buf[33] = {0};
        memcpy(ssid_buf, &frame_body[offset + 2], tag_length);
        ssid = String(ssid_buf);
        
        if (ssid == YOUR_ROUTER_SSID) {
          attack_type = "probe_request";
        }
        break;
      }
      offset += 2 + tag_length;
    }
  }
  // Detect Authentication
  else if (ptype == 0 && subtype == 11) {
    attack_type = "auth_attempt";
  }
  // Detect Association
  else if (ptype == 0 && subtype == 0) {
    attack_type = "association";
  }
  // Detect Deauth
  else if (ptype == 0 && subtype == 12) {
    attack_type = "deauth_attack";
  }
  
  // If intrusion detected, store in buffer
  if (attack_type != "") {
    packetCount++;
    
    // Add to circular buffer
    if (bufferCount < PACKET_BUFFER_SIZE) {
      BufferedPacket* bp = &packetBuffer[bufferHead];
      strcpy(bp->mac, source_mac);
      bp->rssi = rssi;
      bp->channel = channel;
      strcpy(bp->attack_type, attack_type.c_str());
      strcpy(bp->ssid, ssid.c_str());
      bp->timestamp = millis();
      
      bufferHead = (bufferHead + 1) % PACKET_BUFFER_SIZE;
      bufferCount++;
      
      // Visual feedback
      digitalWrite(2, LOW);
      delay(10);
      digitalWrite(2, HIGH);
      
      Serial.printf("üì¶ Buffered: %s | %s | Buffer: %d/%d\n", 
                   source_mac, attack_type.c_str(), bufferCount, PACKET_BUFFER_SIZE);
    } else {
      Serial.println("‚ö†Ô∏è Buffer full! Packet dropped");
    }
  }
}

// ========== SETUP ==========
void setup() {
  Serial.begin(115200);
  delay(1000);
  
  Serial.println("\n\n========================================");
  Serial.println("   ESP32 REAL WIDS MONITOR");
  Serial.println("========================================");
  
  esp32Mac = WiFi.macAddress();
  Serial.print("ESP32 MAC: ");
  Serial.println(esp32Mac);
  Serial.print("Protecting SSID: ");
  Serial.println(YOUR_ROUTER_SSID);
  
  pinMode(2, OUTPUT);
  digitalWrite(2, HIGH);
  
  // Initial WiFi connection
  connectToWiFi();
  
  // Setup promiscuous mode
  setupPromiscuousMode();
  
  Serial.println("\n‚úÖ WIDS Monitor ACTIVE");
  Serial.println("üì° Listening for REAL WiFi packets...");
  Serial.println("========================================\n");
}

// ========== CONNECT TO WIFI ==========
void connectToWiFi() {
  if (WiFi.status() == WL_CONNECTED) {
    wifiConnected = true;
    return;
  }
  
  Serial.print("Connecting to WiFi...");
  WiFi.begin(WIFI_SSID, WIFI_PASS);
  
  int attempts = 0;
  while (WiFi.status() != WL_CONNECTED && attempts < 20) {
    delay(500);
    Serial.print(".");
    digitalWrite(2, !digitalRead(2));
    attempts++;
  }
  
  if (WiFi.status() == WL_CONNECTED) {
    wifiConnected = true;
    Serial.println("\n‚úÖ WiFi connected!");
    Serial.print("IP: ");
    Serial.println(WiFi.localIP());
    digitalWrite(2, HIGH);
  } else {
    wifiConnected = false;
    Serial.println("\n‚ùå WiFi failed!");
    digitalWrite(2, LOW);
  }
}

// ========== SETUP PROMISCUOUS MODE ==========
void setupPromiscuousMode() {
  Serial.println("Initializing promiscuous mode...");
  
  wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();
  esp_wifi_init(&cfg);
  esp_wifi_set_storage(WIFI_STORAGE_RAM);
  esp_wifi_set_mode(WIFI_MODE_NULL);
  esp_wifi_start();
  esp_wifi_set_promiscuous(true);
  esp_wifi_set_promiscuous_rx_cb(&wifi_sniffer_packet_handler);
  
  wifi_promiscuous_filter_t filter = {
    .filter_mask = WIFI_PROMIS_FILTER_MASK_MGMT
  };
  esp_wifi_set_promiscuous_filter(&filter);
  
  Serial.println("‚úÖ Promiscuous mode active");
}

// ========== SEND BUFFERED PACKETS ==========
void sendBufferedPackets() {
  if (!wifiConnected || bufferCount == 0) return;
  
  int sent = 0;
  while (bufferCount > 0 && sent < 10) { // Send max 10 per cycle
    BufferedPacket* bp = &packetBuffer[bufferTail];
    
    HTTPClient http;
    http.begin(serverUrl);
    http.addHeader("Content-Type", "application/json");
    http.setTimeout(2000); // 2 second timeout
    
    StaticJsonDocument<512> doc;
    doc["sensor_id"] = sensor_id;
    doc["mac"] = bp->mac;
    doc["rssi"] = bp->rssi;
    doc["channel"] = bp->channel;
    doc["attack_type"] = bp->attack_type;
    doc["ssid"] = bp->ssid;
    doc["timestamp"] = bp->timestamp;
    doc["esp32_mac"] = esp32Mac;
    
    String jsonPayload;
    serializeJson(doc, jsonPayload);
    
    int httpCode = http.POST(jsonPayload);
    
    if (httpCode > 0) {
      Serial.printf("‚úÖ Sent buffered: %s | %s\n", bp->mac, bp->attack_type);
      sentCount++;
      
      // Remove from buffer
      bufferTail = (bufferTail + 1) % PACKET_BUFFER_SIZE;
      bufferCount--;
      sent++;
    } else {
      Serial.printf("‚ùå Send failed: %d - stopping for now\n", httpCode);
      http.end();
      break;
    }
    
    http.end();
    delay(100); // Small delay between sends
  }
  
  if (sent > 0) {
    Serial.printf("üì§ Sent %d buffered packets | Remaining: %d\n", sent, bufferCount);
  }
}

// ========== MAIN LOOP ==========
void loop() {
  unsigned long now = millis();
  
  // Check WiFi every 10 seconds
  if (now - lastReconnectAttempt > 10000) {
    if (WiFi.status() != WL_CONNECTED) {
      wifiConnected = false;
      Serial.println("‚ùå WiFi lost - attempting reconnect...");
      WiFi.reconnect();
      
      // Wait a bit for connection
      int attempts = 0;
      while (WiFi.status() != WL_CONNECTED && attempts < 10) {
        delay(500);
        Serial.print(".");
        attempts++;
      }
      
      if (WiFi.status() == WL_CONNECTED) {
        wifiConnected = true;
        Serial.println("\n‚úÖ WiFi reconnected!");
        Serial.print("IP: ");
        Serial.println(WiFi.localIP());
      }
    } else {
      wifiConnected = true;
    }
    lastReconnectAttempt = now;
  }
  
  // Send buffered packets when WiFi is available
  if (wifiConnected && bufferCount > 0) {
    sendBufferedPackets();
  }
  
  // Channel hopping
  static unsigned long lastChannelChange = 0;
  static uint8_t currentChannel = 1;
  
  if (now - lastChannelChange > 1000) {
    currentChannel = (currentChannel % 13) + 1;
    esp_wifi_set_channel(currentChannel, WIFI_SECOND_CHAN_NONE);
    lastChannelChange = now;
    
    Serial.printf("üì∂ Scanning channel %d | Detected: %u | Buffered: %d | Sent: %u\n", 
                 currentChannel, packetCount, bufferCount, sentCount);
  }
  
  // Heartbeat every 30 seconds
  if (now - lastHeartbeat > 30000) {
    Serial.printf("üíì Heartbeat - Total: %u | Buffered: %d | Sent: %u\n", 
                 packetCount, bufferCount, sentCount);
    lastHeartbeat = now;
  }
  
  delay(10);
}
